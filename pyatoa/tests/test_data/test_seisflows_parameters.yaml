# Manually edited from SPECFEM2D example problem (seisflows examples 3)
# Date: May 17, 2022; Commit: 26a8441
# //////////////////////////////////////////////////////////////////////////////
#
#                        SeisFlows3 YAML Parameter File
#
# //////////////////////////////////////////////////////////////////////////////
#
# Modules correspond to the structure of the source code, and determine
# SeisFlows3' behavior at runtime. Each module requires its own sub-parameters.
#
# .. rubric::
#   - To determine available options for modules listed below, run:
#       > seisflows print modules
#   - To auto-fill with docstrings and default values (recommended), run:
#       > seisflows configure
#   - To set values as NoneType, use: null
#   - To set values as infinity, use: inf
#
#                                    MODULES
#                                    ///////
# WORKFLOW (str):    The method for running SeisFlows3; equivalent to main()
# SOLVER (str):      External numerical solver to use for waveform simulations
# SYSTEM (str):      Computer architecture of the system being used
# OPTIMIZE (str):    Optimization algorithm for the inverse problem
# PREPROCESS (str):  Preprocessing schema for waveform data
# POSTPROCESS (str): Postprocessing schema for kernels and gradients
# ==============================================================================
WORKFLOW: inversion
SOLVER: specfem2d
SYSTEM: workstation
OPTIMIZE: LBFGS 
PREPROCESS: pyatoa
POSTPROCESS: base

# =============================================================================
#                                    SYSTEM                                    
#                                    //////                                    
# TITLE (str):
#   The name used to submit jobs to the system, defaults to the name of the
#   working directory
# PRECHECK (list):
#   A list of parameters that will be displayed to stdout before 'submit' or
#   'resume' is run. Useful for manually reviewing important parameters prior
#   to system submission
# LOG_LEVEL (str):
#   Verbosity output of SF3 logger. Available from least to most verbosity:
#   'CRITICAL', 'WARNING', 'INFO', 'DEBUG'; defaults to 'DEBUG'
# VERBOSE (bool):
#   Level of verbosity provided to the output log. If True, log statements
#   will declare what module/class/function they are being called from.
#   Useful for debugging but also very noisy.
# MPIEXEC (str):
#   Function used to invoke executables on the system. For example 'srun' on
#   SLURM systems, or './' on a workstation. If left blank, will guess based
#   on the system.
# NTASK (int):
#   Number of separate, individual tasks. Also equal to the number of desired
#   sources in workflow
# NPROC (int):
#   Number of processor to use for each simulation
# =============================================================================
TITLE: specfem2d_workstation_example
PRECHECK:
    - TITLE
LOG_LEVEL: DEBUG
VERBOSE: False
MPIEXEC:
NTASK: 3
NPROC: 1

# =============================================================================
#                                  PREPROCESS                                  
#                                  //////////                                  
# UNIT_OUTPUT (str):
#   Data units. Must match the synthetic output of external solver.
#   Available: ['DISP': displacement, 'VEL': velocity, 'ACC': acceleration]
# START_PAD (float):
#   For data gathering; time before origin time to gather. START_PAD >= T_0
#   in SPECFEM constants.h.in. Positive values only
# END_PAD (float):
#   For data gathering; time after origin time to gather. END_PAD >= NT * DT
#   (of Par_file). Positive values only
# MIN_PERIOD (float):
#   Minimum filter corner in unit seconds. Bandpass filter if set with
#   `MAX_PERIOD`, highpass filter if set without `MAX_PERIOD`, no filtering
#   if not set and `MAX_PERIOD also not set
# MAX_PERIOD (float):
#   Maximum filter corner in unit seconds. Bandpass filter if set with
#   `MIN_PERIOD`, lowpass filter if set without `MIN_PERIOD`, no filtering if
#   not set and `MIN_PERIOD also not set
# CORNERS (int):
#   Number of filter corners applied to filtering
# CLIENT (str):
#   Client name for ObsPy FDSN data gathering. Pyatoa will attempt to collect
#   waveform and metadata based on network and station codes provided in the
#   SPECFEM STATIONS file. If set None, no FDSN gathering will be attempted
# ROTATE (bool):
#   Attempt to rotate waveform components from NEZ -> RTZ
# PYFLEX_PRESET (str):
#   Parameter map for misfit window configuration defined by Pyflex. IF None,
#   misfit and adjoint sources will be calculated on whole traces. For
#   available choices, see Pyatoa docs page (pyatoa.rtfd.io)
# FIX_WINDOWS (bool or str):
#   How to address misfit window evaluation at each evaluation. Options to
#   re-use misfit windows collected during an inversion, available options:
#   [True, False, 'ITER', 'ONCE'] True: Re-use windows after first evaluation
#   (i01s00); False: Calculate new windows each evaluation; 'ITER': Calculate
#   new windows at first evaluation of each iteration (e.g., i01s00...
#   i02s00...'ONCE': Calculate new windows at first evaluation of the
#   workflow, i.e., at PAR.BEGIN
# ADJ_SRC_TYPE (str):
#   Adjoint source type to evaluate misfit, defined by Pyadjoint. Currently
#   available options: ['cc': cross-correlation, 'mt': multitaper, wav:
#   waveform']
# PLOT (bool):
#   Attempt to plot waveforms and maps as PDF files at each function
#   evaluation
# PYATOA_LOG_LEVEL (str):
#   Log level to set Pyatoa, Pyflex, Pyadjoint. Available: ['null': no
#   logging, 'warning': warnings only, 'info': task tracking, 'debug': log
#   all small details (recommended)]
# SAVE_DATASETS (bool):
#   Save PyASDF HDF5 datasets to disk. These datasets store waveform data,
#   metadata, misfit windows, adjoint sources and configuration parameters
# SAVE_FIGURES (bool):
#   Save output waveform figures to disk as PDFs
# SAVE_LOGS (bool):
#   Save event-specific Pyatoa logs to disk as .txt files
# =============================================================================
UNIT_OUTPUT: DISP
START_PAD: 48
END_PAD: 300.0
MIN_PERIOD: 
MAX_PERIOD: 
CORNERS: 4
CLIENT:
ROTATE: False
PYFLEX_PRESET: 
FIX_WINDOWS: False
ADJ_SRC_TYPE: cc
PLOT: True
PYATOA_LOG_LEVEL: INFO
SAVE_DATASETS: True
SAVE_FIGURES: True
SAVE_LOGS: True

# =============================================================================
#                                    SOLVER                                    
#                                    //////                                    
# MATERIALS (str):
#   Material parameters used to define model. Available: ['ELASTIC': Vp, Vs,
#   'ACOUSTIC': Vp, 'ISOTROPIC', 'ANISOTROPIC']
# DENSITY (str):
#   How to treat density during inversion. Available: ['CONSTANT': Do not
#   update density, 'VARIABLE': Update density]
# ATTENUATION (str):
#   If True, turn on attenuation during forward simulations, otherwise set
#   attenuation off. Attenuation is always off for adjoint simulations.
# COMPONENTS (str):
#   Components used to generate data, formatted as a single string, e.g. ZNE
#   or NZ or E
# SOLVERIO (int):
#   The format external solver files. Available: ['fortran_binary', 'adios']
# NT (float):
#   Number of time steps set in the SPECFEM Par_file
# DT (float):
#   Time step or delta set in the SPECFEM Par_file
# F0 (float):
#   Dominant source frequency
# FORMAT (float):
#   Format of synthetic waveforms used during workflow, available options:
#   ['ascii', 'su']
# SOURCE_PREFIX (str)
#   Prefix of SOURCE files in path SPECFEM_DATA. By default, 'SOURCE' for
#   SPECFEM2D
# =============================================================================
MATERIALS: elastic
DENSITY: constant
ATTENUATION: False
COMPONENTS: ZNE
SOLVERIO: fortran_binary
NT: 5000
DT: 0.06
F0: 0.084
FORMAT: ascii
SOURCE_PREFIX: CMTSOLUTION

# =============================================================================
#                                  POSTPROCESS                                 
#                                  ///////////                                 
# SMOOTH_H (float):
#   Gaussian half-width for horizontal smoothing in units of meters. If 0.,
#   no smoothing applied
# SMOOTH_V (float):
#   Gaussian half-width for vertical smoothing in units of meters
# TASKTIME_SMOOTH (int):
#   Large radii smoothing may take longer than normal tasks. Allocate
#   additional smoothing task time as a multiple of TASKTIME
# =============================================================================
SMOOTH_H: 0.0
SMOOTH_V: 0.0
TASKTIME_SMOOTH: 1

# =============================================================================
#                                   OPTIMIZE                                   
#                                   ////////                                   
# LINESEARCH (str):
#   Algorithm to use for line search, see seisflows.plugins.line_search for
#   available choices
# PRECOND (str):
#   Algorithm to use for preconditioning gradients, see
#   seisflows3.plugins.preconds for available choices
# STEPCOUNTMAX (int):
#   Max number of trial steps in line search before a change in line search
#   behavior
# STEPLENINIT (float):
#   Initial line search step length, as a fraction of current model
#   parameters
# STEPLENMAX (float):
#   Max allowable step length, as a fraction of current model parameters
# LBFGSMEM (int):
#   Max number of previous gradients to retain in local memory
# LBFGSMAX (int):
#   LBFGS periodic restart interval, between 1 and 'inf'
# LBFGSTHRESH (float):
#   LBFGS angle restart threshold
# =============================================================================
LINESEARCH: Backtrack
PRECOND:
STEPCOUNTMAX: 10
STEPLENINIT: 0.05
STEPLENMAX: 0.5
LBFGSMEM: 3
LBFGSMAX: inf
LBFGSTHRESH: 0.0

# =============================================================================
#                                   WORKFLOW                                   
#                                   ////////                                   
# CASE (str):
#   Type of inversion, available: ['data': real data inversion, 'synthetic':
#   synthetic-synthetic inversion]
# RESUME_FROM (str):
#   Name of task to resume inversion from
# STOP_AFTER (str):
#   Name of task to stop inversion after finishing
# SAVEMODEL (bool):
#   Save final model files after each iteration
# SAVEGRADIENT (bool):
#   Save gradient files after each iteration
# SAVEKERNELS (bool):
#   Save event kernel files after each iteration
# SAVETRACES (bool):
#   Save waveform traces after each iteration
# SAVERESIDUALS (bool):
#   Save waveform residuals after each iteration
# SAVEAS (str):
#   Format to save models, gradients, kernels. Available: ['binary': save
#   files in native SPECFEM .bin format, 'vector': save files as NumPy .npy
#   files, 'both': save as both binary and vectors]
# BEGIN (int):
#   First iteration of workflow, 1 <= BEGIN <= inf
# END (int):
#   Last iteration of workflow, BEGIN <= END <= inf
# =============================================================================
CASE: synthetic
RESUME_FROM:     
STOP_AFTER: initialize
SAVEMODEL: True
SAVEGRADIENT: True
SAVEKERNELS: False
SAVETRACES: False
SAVERESIDUALS: False
SAVEAS: binary
BEGIN: 1
END: 1

# =============================================================================
#                                     PATHS                                    
#                                     /////                                    
# SCRATCH:
#   scratch path to hold temporary data during workflow
# OUTPUT:
#   directory to save workflow outputs to disk
# SYSTEM:
#   scratch path to hold any system related data
# LOCAL:
#   path to local data to be used during workflow
# LOGFILE:
#   the main output log file where all processes will track their status
# PREPROCESS:
#   scratch/ path to store waveform data and figures. Pyatoa will generate an
#   internal directory structure here
# DATA:
#   path to data available to workflow
# SOLVER:
#   scratch path to hold solver working directories
# SPECFEM_BIN:
#   path to the SPECFEM binary executables
# SPECFEM_DATA:
#   path to the SPECFEM DATA/ directory containing the 'Par_file', 'STATIONS'
#   file and 'CMTSOLUTION' files
# MASK:
#   Directory to mask files for gradient masking
# OPTIMIZE:
#   scratch path to store data related to nonlinear optimization
# MODEL_INIT:
#   location of the initial model to be used for workflow
# MODEL_TRUE:
#   Target model to be used for PAR.CASE == 'synthetic'
# FUNC:
#   scratch path to store data related to function evaluations
# GRAD:
#   scratch path to store data related to gradient evaluations
# HESS:
#   scratch path to store data related to Hessian evaluations
# =============================================================================
PATHS:
    SCRATCH: ./scratch
    OUTPUT: ./output
    SYSTEM: ./scratch/system
    LOCAL:
    LOGFILE: ./output_sf3.txt
    PREPROCESS: ./scratch/preprocess
    DATA:
    SOLVER: ./scratch/solver
    SPECFEM_BIN: ./bin
    SPECFEM_DATA: ./DATA
    MASK:
    OPTIMIZE: ./scratch/optimize
    MODEL_INIT: ./OUTPUT_FILES_INIT
    MODEL_TRUE: ./OUTPUT_FILES_TRUE
    FUNC: ./scratch/evalfunc
    GRAD: ./scratch/evalgrad
    HESS: ./scratch/evalhess
