#!/usr/bin/env python3
"""
Iteration waveform plotter for ASDFDataSets generated by SeisFlows inversions. 

Generates a multi column, multi row plot that shows data-synthetic comparisons
for all (or chosen) models for a chosen station. Options for plotting windows
and calculating VRL are also available.

See Chow et al., 2020 Figure 10 for an example figure.

.. rubric::

        wt = WaveTrain(ds=ds)
        wt.plot(station="NN.SSS", component_list=["Z", "N", "E"], 
                min_period=30, max_period=50)
"""
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

from pyatoa import Manager
from pyatoa.utils.calculate import vrl
from pyatoa.utils.form import format_event_name


class WaveTrain:
    """
    Simple plotter class to show waveform improvements for a given station
    whose data are saved inside an ASDFDataSet generated by a Pyaflowa SeisFlows
    inversion. Only requires the ASDFDataSet as input.
    """
    def __init__(self, ds, models=None):
        """
        Initiate empty objects and keep dataset as an internal attribute

        :type ds: pyasdf.ASDFDataSet
        :param ds: ASDFDataSet generated by a SeisFlows inversion
        :type models: list
        :param models: list of models to plot, which must match the available
            iteration/step_count stored in the ASDFDataSet. Models should
            be in the format i01/s00 (iteration/step_count). If not provided
            the class will attempt to find all available models in the dataset,
            by assuming that the first model is i01/s00, that each subsequent
            model is i0?/s00, and that the final model is the last step of the
            last iteration.
        """
        self.ds = ds
        self.models = models
        self.evaluations = self._get_all_evaluations()

        if self.models:
            assert set(self.models).issubset(set(self.evaluations)), \
                   f"Models don't match expected evaluations in the ASDFDataSet"
        else:
            self.models = self.evaluations
    
    def _get_all_evaluations(self):
        """Get all available evaluations in the dataset, used for validating
        model names"""
        evaluations = []
        for iteration in self.ds.auxiliary_data.Configs.list():
            for step in self.ds.auxiliary_data.Configs[iteration].list():
                evaluations.append(f"{iteration}/{step}")
        return evaluations  

    def _gather(self, station, model, min_period=None, max_period=None,
               **kwargs):
        """
        Gather data from an ASDFDataSet based on the given model (iter/step)

        :type station: str
        :param station: name of the station as listed in the ASDFDataSet, in
            the format NN.SSS (N=network, S=station)
        :type model: str
        :param model: model to gather data for, in the format i01/s00
        :type min_period: float
        :param min_period: minimum period for the filter corners, if not given
            no filter applied
        :type max_period: float
        :param max_period: maximum period for the filter corners, if not given
            no filter applied
        :rtype: (obspy.core.stream.Stream, obspy.core.stream.Stream, dict, 
                 float)
        :return: observed, synthetic, windows, time offset [s]
        """
        # Use the Manager class to load in waveform data
        mgmt = Manager(ds=self.ds)
        mgmt.load(code=station, path=model, windows=True)

        # Overwrite the filter corners stored in the dataset
        mgmt.config.min_period = min_period
        mgmt.config.max_period = max_period
        mgmt.standardize()
        mgmt.preprocess(**kwargs)

        return mgmt.st_obs, mgmt.st_syn, mgmt.windows, \
            mgmt.stats.time_offset_sec

    def _setup_plot(self, nrows, ncols, **kwargs):
        """
        Dynamically set up plots according to number_of given
        Returns a list of lists of axes objects
        e.g. axes[i][j] gives the ith column and the jth row

        :type nrows: int
        :param nrows: number of rows in the gridspec
        :type ncols: int
        :param ncols: number of columns in the gridspec
        :rtype axes: matplotlib axes
        :return axes: axis objects
        """
        figure = kwargs.get("figure", None)
        subplot_spec = kwargs.get("subplot_spec", None)
        dpi = kwargs.get("dpi", 150)
        figsize = kwargs.get("figsize", (1200 / dpi, (240 * nrows) / dpi))
        fontsize = kwargs.get("fontsize", 12)
        axis_linewidth = kwargs.get("axis_linewidth", 2)
        xticks = kwargs.get("xticks", True)
        yticks = kwargs.get("yticks", True)
        minor_ticks = kwargs.get("minor_ticks", False)

        # Initiate the figure, allow for external figure objects
        if figure is None:
            f = plt.figure(figsize=figsize, dpi=dpi)
        else:
            f = figure

        # Initiate gridspec, allow for nested grids
        subplot_kwargs = {"hspace": 0, "wspace": 0.025, 
                          "width_ratios": [5] * ncols, 
                          "height_ratios": [1] * nrows}
        if subplot_spec is None:
            gs = mpl.gridspec.GridSpec(nrows, ncols, **subplot_kwargs)
        else:
            gs = mpl.gridspec.GridSpecFromSubplotSpec(nrows, ncols,
                                                      subplot_spec=subplot_spec,
                                                      **subplot_kwargs)

        axes = [[] for _ in range(nrows)]
        for row in range(0, gs.get_geometry()[0]):
            for col in range(0, gs.get_geometry()[1]):
                # First column can't share y-values
                if col == 0:
                    sharey = None
                else:
                    sharey = axes[row][0]
                # First entry can't share x-values
                if row == 0 and col == 0:
                    sharex = None
                else:
                    sharex = axes[0][0]

                ax = plt.subplot(gs[row, col], sharey=sharey, sharex=sharex)

                ax.set_axisbelow(True)
                
                left = bool(yticks)
                bottom = bool(xticks) 

                ax.tick_params(which='major', direction='in', top=False,
                               right=False, left=left, bottom=bottom, 
                               labelsize=fontsize,
                               length=5, width=2*axis_linewidth/3)
                if minor_ticks:
                    ax.minorticks_on()
                    ax.tick_params(which='minor', direction='in', length=3, 
                                   top=False, bottom=bottom, right=False, 
                                   left=left, width=2*axis_linewidth/3)
                if col == 0:
                    ax.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))
                    # Make sure the scientific notation has the same4fontsize
                    ax.yaxis.get_offset_text().set_fontsize(fontsize)

                for axis in ["top", "bottom", "left", "right"]:
                    ax.spines[axis].set_linewidth(axis_linewidth)

                # Set the grids on
                axes[row].append(ax)

        # remove x-tick labels except for last axis
        for row in axes[:-1]:
            for col in row:
                plt.setp(col.get_xticklabels(), visible=False)

        # Turn off the y-tick labels and sci notation for columns except first
        for row in axes:
            # for col in row[1:]:
            for col in row[:]:
                plt.setp(col.get_yticklabels(), visible=False)
                col.yaxis.get_offset_text().set_visible(False)

        return f, axes

    def plot(self, station, min_period=None, max_period=None, models=None,
             component_list=None, title=None, label_tshift=True, xlim=None, 
             calculate_vrl=True, show=True, save=False, **kwargs):
        """
        Plot waveforms iterative based on model updates. Calls `_gather`
        to grab preprocessed waveform data from the internal ASDFDataSet `ds`.
        Kwargs are passed to the underlying Manager.preprocess. function.

        :type station: str
        :param station: name of the station as listed in the ASDFDataSet, in
            the format NN.SSS (N=network, S=station)
        :type min_period: float
        :param min_period: minimum period for the filter corners, if not given
            no filter applied
        :type max_period: float
        :param max_period: maximum period for the filter corners, if not given
            no filter applied
        :type models: list
        :param models: list of models to plot, if not set, all models plotted
        :type component_list: list
        :param component_list: list of components to plot, e.g. ["Z", "N", "E"]
        :type title: str
        :param title: title of the plot, if not set, the station code is used
        :type xlim: list
        :param xlim: x-axis limits for the plot, if not set, uses full time
        :type calculate_vrl: bool
        :param calculate_vrl: calculate the variance reduction for each model 
            and annotate the value in the corner of each figure
        :type label_tshift: bool
        :param label_tshift: label the time shift in the top corner of each
            window in units seconds
        :type show: bool
        :param show: Show the plot or do not
        :type save: str
        :param save: if given, save the figure to this path
        """
        obs_lw = kwargs.get("obs_lw", 1.)
        syn_lw = kwargs.get("syn_lw", 1.25)
        fontsize = kwargs.get("fontsize", 12)
        obs_color = kwargs.get("color_obs", "k")

        # Colors for each component that generally work well together
        syn_colors = ["orangered", "dodgerblue", "yellowgreen"]

        # Dynamically retrieve component list from the dataset
        if component_list is None:
            component_list = [_.stats.component for _ in 
                              self.ds.waveforms[station].observed]
        # User set model values or not. Check if these are valid model values
        if models is None:
            models = self.models

        # One row per component, one column for init and final each
        f, axes = self._setup_plot(nrows=len(models), 
                                   ncols=len(component_list), **kwargs)

        # Plot each component in a different column
        s_init = []
        for row, model in enumerate(models):
            obs, syn, windows, t_offset = self._gather(
                station=station, min_period=min_period, max_period=max_period,
                model=model, **kwargs
                )  
            # Loop through waveforms first to get max y value
            max_amp = 0
            for o, s in zip(obs, syn):
                max_amp = max(max_amp, np.max(np.abs(o.data)), 
                              np.max(np.abs(s.data))) * 1.05

            for col, comp in enumerate(component_list):
                o = obs.select(component=comp)[0]
                s = syn.select(component=comp)[0]
                axes[row][col].plot(o.times() + t_offset, o.data, obs_color, 
                                    zorder=10, linewidth=obs_lw)
                axes[row][col].plot(s.times() + t_offset, s.data, 
                                    syn_colors[col],  zorder=11, 
                                    linewidth=syn_lw)
                
                # Plot the windows as rectangles if they are available
                if comp in windows:
                    for window in windows[comp]:
                        tleft = window.left * window.dt + t_offset
                        tright = window.right * window.dt
                        r = Rectangle(xy=(tleft, -1 * max_amp),  
                                    width=tright - tleft,
                                    height=max_amp * 2, fc="orange", 
                                    ec="k", alpha=0.1, zorder=10
                                    )
                        axes[row][col].add_patch(r)
                        # Add timeshift label in top corner of window
                        if label_tshift:
                            tshift_s = window.cc_shift * window.dt
                            sign = "+" if tshift_s > 0 else "-"

                            axes[row][col].text(
                                x=tleft, y=max_amp - max_amp * 0.05, 
                                s=f"{sign}{np.abs(tshift_s):.2f}s",  
                                verticalalignment="top", 
                                fontsize=6, 
                                )
                
                # Turn off y-ticks, they carry no information
                axes[row][col].set_yticks([])

                # Set all y-max values to the maximum amplitude in the row
                axes[row][col].set_ylim([-1 * max_amp, max_amp])

                # First row gets the component formatted into the corner
                if row == 0:
                    axes[row][col].text(
                        x=0.99, y=0.01, s=comp.upper(), fontsize=fontsize, 
                        c=syn_colors[col], horizontalalignment="right", 
                        verticalalignment="bottom", 
                        transform=axes[row][col].transAxes
                        )
                    s_init.append(s)
                # All other rows get the VRL value which determines improvement
                else:
                    if calculate_vrl:
                        vrl_val = vrl(o.data, s.data, s_init[col].data)
                        axes[row][col].text(
                            x=1., y=.95, s=f"VRL={vrl_val:.2f}", 
                            fontsize=8, 
                            horizontalalignment="right", 
                            verticalalignment="top",
                            transform=axes[row][col].transAxes
                            )
            
            # Write the model number in the y-label of the leftmost column
            axes[row][0].set_ylabel(model, fontsize=fontsize)
                    
        # Finalize plot looks: set time axis label
        middle_column = len(component_list) // 2
        axes[-1][middle_column].set_xlabel("Time [s]", fontsize=fontsize)

        # Set the time axes which should be the same for all
        if xlim is None:
            xlim = [_ + t_offset for _ in [o.times()[0], o.times()[-1]]]
        plt.xlim(xlim)

        # Set title
        if title is None:
            title = (f"{format_event_name(self.ds)} -> {station} "
                     f"({min_period}-{max_period}s)")
        plt.suptitle(title, fontsize=fontsize)

        # Save the generated figure
        if save:
            plt.savefig(save)
        if show:
            plt.show()

        return f, axes

